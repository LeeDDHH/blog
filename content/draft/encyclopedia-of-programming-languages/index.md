---
read_start_date: "2021-08-21"
read_end_date: ""
---

# プログラミング言語大全

### プログラミング言語とは何か

#### なぜ複数のプログラミング言語が存在するのか

##### 最適な道具

- プログラミング言語ごとに得意分野が異なる
  - web
    - PHP、Ruby、Pythonなど
  - iPhone、Mac
    - Swift、Objective-C
  - データベース操作
    - SQL
  - それぞれの適した用途がある
  - 何をどのように作るかに応じて、プログラミング言語を変える必要がある
  - プログラミング言語は複数の用途に使えるようになっているが、得意分野と苦手分野はある
    - なので、仕事でプログラミングをしているのであれば2、3つ以上の言語を使える人が大半

##### プログラミング言語の進化

- 新しい技術が次々と生まれている
- 新しい技術に見合ったプログラミング言語が用意される
- 新しいプログラミング言語そのものが技術を刷新していく
- あるプログラミング言語では解決できない新しいタイプの課題が見つかる
- これまで時間をかけて作っていた処理を、簡単に実現できるようになることもある

##### プログラミング言語の多様性

- 自由に作れるから生まれる多様性
- 独自の事情やセールスポイントがあるため、用途が似ていたとしても、並立して生き残っていく
- AppleのiOSとGoogleのAndroidのOS
  - OSが統一されないのは、それぞれのプラットフォームが自前で提供していることに価値を見出しているから
- 純粋な興味からプログラミング言語を作る人もいる
- 大きな視点で考えれば似たようなものでも、どのプログラミング言語も独自のバックグラウンドや特徴がある

---

### どのプログラミング言語を学ぶべきか

#### 高速なプログラミング言語

- 一般的に、静的型付けでコンパイルを必要とする言語のほうが、動的型付け言語より実行速度が高速
- 静的型付け言語でも、ネイティブコードを出力できるC、C++がVMを介する必要のあるバイトコードを生成するJavaなどの言語より高速な傾向がある

#### 書きやすい、生産性の高いプログラミング言語

- プログラミング言語の書きやすさは数値化しづらい
  - 情報がどれだけあるか
  - ライブラリが使いやすいか
  - 言語そのものが書きやすいか
  - などの観点がある
- Python、Ruby、Kotlinなどがある

---

### プログラミング言語の活躍するシーン

#### Webアプリ（Webアプリケーション/Webサービス）

- サーバー側
  - PHP
  - Python
  - Ruby
  - Node.js(JavaScript)
  - Java
  - など

- クライアント側
  - JavaScript
  - WebAssembly

#### スマートフォンアプリ

- Android
  - Java
  - Kotlin

- iOS
  - Objective-C
  - Swift

- クロスプラットフォーム
  - Dart(Flutter)
  - JavaScript(React Native)

#### デスクトップアプリ

- Windows
  - C++(MFC、WTL、Qt)
  - C#
  - Visual Basic

- Mac
  - Objective-C
  - Swift

- クロスプラットフォーム
  - JavaScript(Electron)

#### 人工知能/機械学習

- 画像認識、音声認識、機械翻訳、チャットボット、自動運転など

- 機械学習
  - Python
  - R
  - C++
  - Java
  - JavaScript

#### システムプログラミングや高性能シフトウェアの開発

- OS、デバイスドライバーなどのシステムプログラム
  - 高速な応答性や目盛り効率の高さが求められる
  - DB、Webブラウザなどのソフトウェアもある
  - 効率よくハードウェアの性能を最大限引き出すプログラミング言語が必要
  - C/C++、Rust、Javaなど

#### 組み込み機器

- さまざまな機器に組み込まれる制御システム
  - TV、オーディオ機器から自動車の制御、工業機械の制御
  - C/C++、Python、Javaなど
  - 処理能力が限定されて、制限が多い環境でも動かしやすいC/C++が需要にマッチする
  - ある程度立地な環境ならJavaも使われる
  - Linux上で動くPythonもある

#### ゲーム制作

- スマホ
  - Kotlin
  - Swift

- Webアプリケーション
  - JavaScript

- Unity
  - C#

- Unreal Engine
  - C++

- コンシューマーゲーム
  - ハードの性能を引き出す必要があるので、C/C++が多くの場面で使われている

#### コマンドツール

- 提供したいプラットフォームできちんと動くこと（移植性）やツールの書きやすさが求められる

- C、Go、Perl、Bash/Shell Script

#### その他の用途

- プログラミング言語を作るためのプログラミング言語
  - C、OCaml

- データベース操作
  - SQL

---

### プログラミング言語を分類して考える

- 静的型付け言語
  - 大人数で開発することが決まっている
  - 値のデータの種類による不具合を用意に検出できる
- 動的型付け言語
  - 少人数の開発
  - 開発速度を重視する
- オブジェクト指向の言語
  - 長期に渡り使われることが若ており、メンテナンスが継続的に行われるのが予想される
  - ライブラリの再利用性や拡張が容易

#### プログラミング言語と型

- プログラミング言語を分類するためのいくつかの基準
  - 型の取り扱い
- 静的型付け（Static typing）
  - 変数、関数の型がプログラムの実行前に決まっている言語
- 動的型付け（Dynamic typing）
  - 実行時に方が決まる言語

- 静的型付け
  - 型が厳格
  - プログラム実行前に型の正当性チェックを行う
    - **静的型検査**
    - データの種類違いによるミスなどが防げる
  - IDEを利用することで、該当する型のプロパティやメソッドなどの自動補完機能を利用できる
    - エラー回避、可読性の向上に役立つ機能も持つ
  - 変数、関数の型を明示的に宣言する必要がある
  - C、C++、Java、Scala、Haskell、OCamlなど

- 動的型付け
  - 明示的な変数の型注釈ができない
    - 型を書く手間が必要ない
  - プログラム実行時に変数の方が決定されるので、型が間違っている場合、実行時のエラーが出るか、暗黙的にその型に変換される
  - 事前に型が判定できないので、プログラムの実行速度の最適化がしづらい
  - Python、Ruby、Perl、PHP、Common Lisp、Groovyなど

- 命令型と宣言型
  - **命令型（Imperative programming）**
    - プログラムで順に処理の方法（how）を書いていく
  - **宣言型（Declarative programming）**
    - プログラムで該当する条件ややるべき状態など処理の性質（what）を書く

- 宣言型
  - 論理型
  - 関数型

- 命令型
  - 手続き型
  - オブジェクト指向

- 構造化と非構造化
  - **構造化（Structured programming）**
    - プログラムの逐次実行を前提として、分岐/繰り返し/任意の関数の呼び出しを用いてプログラムの構造を記述するパラダイム
    - 現代用いられるほぼすべての言語が持っている特徴

- **手続き型（Procedural programming）**
  - 関数などで処理を構造化できる能力を持ったプログラミング言語
  - オブジェクト指向的な書き方を用いることなくかつ関数型ともある程度距離がある言語
  - データと関数（手続き）はそれぞれ別物として扱われる
  - C、Goなど

- **オブジェクト指向（Object-Oriented Programming）**
  - オブジェクトを中心としてプログラムを構築するパラダイム
  - データ構造や処理は、オブジェクトに包含（ほうがん）される
    - オブジェクトを起点に処理やデータがまとめられる
  - 手続き型から発展し、プログラムの構造を作る能力が向上した経緯がある
    - Java、JavaScriptなどのオブジェクト指向言語では手続き型的なコードを書くこともできる
  - データも手続きも1つのオブジェクトの中にまとめられている
  - プログラムを抽象化する能力を有し、プログラムを整理して書くのに適している
  - Java、JavaScript、Ruby、Pythonなど

- **関数型（Functional programming）**
  - 複数の式を組み合わせてプログラムを作るパラダイム
  - 現代的な言語では、**関数型のエッセンスを持ったオブジェクト指向のプログラミング言語**も数多く見られる
  - JavaScriptにも関数型の影響は強く現れる
  - 「入力に対して、結果を返す」機能だけの関数を用意して組み合わせることでプログラムを作成する
  - JavaScriptやScalaのようにオブジェクト指向と関数型が並立しているケースもある
  - Haskell、OCamlなど

- **論理型（Logic programming）**
  - 論理学の影響下にある
  - 条件を与えることで結果を求める言語
  - Prologなど

- **マルチパラダイム（Multi-paradigm programming）**
  - 手続き型、オブジェクト指向、関数型などのパラダイム（文化あるいは規範）の考え方や書き方に対応したプログラミング言語の総称
  - Scalaなど

- **メタプログラミング（Meta-programming）**
  - 別のプログラムそのものを生成・処理するプログラムを用いるプログラミングパラダイム
  - C++ではテンプレートとマクロを用いることで、コンパイル時に最適なプログラムを生成できる
    - コンパイル時の日付を定数としてプログラムに保存する
    - コンパイル時に必要な計算の一部を終えてプログラムに保存する
    - などの最適化を助ける
  - マクロやテンプレートなどの言語機能により実現する
  - C、C++（テンプレート）、Common Lisp、Rubyなど

- **ビジュアルプログラミング（Visual programming）**
  - 視覚的なインターフェイスを用いてプログラムを作成する言語
  - 教育用途、バッチ処理の自動化などでテキストで記述するよりもわかりやすくなる場合がある
  - 教育用
    - Scratch、Squeak Etoysなど
  - 音声、ビデオ、映像処理のためのリアルタイムなグラフィカルプログラミング環境
    - Pure Data、Maxなど
  - macOSの定型処理をドラッグ&ドロップで処理する
    - Automator

- **コンパイルとインタプリタ**
  - プログラムを実行するために、事前に（明示的な）コンパイルという手順を必要とするのがコンパイル言語
    - 必要としないのがインタプリタ言語
    - ただ、**この分類は絶対的なものではない**
  - 一般的にコンパイル言語に分類されるものが、コンパイルなしで実行できたり、インタプリタ言語が内部的にソースコードをコンパイルしたりする
    - JavaScript
      - 明示的なコンパイルを必要としないものの、実行時にコンパイル（JITコンパイル、Just-In-Timeコンパイル）が行われる
    - Java11
      - 明示的なコンパイルなしにソースコードファイルが実行できる
    - Scala
      - 実際に利用する際はコンパイルすることが多いものの、インタプリタで実行できる
  - 画一的な区分が難しい
  - 一般にインタプリタ言語が手軽だけど実行速度に課題があり、コンパイル言語はコンパイルの手間や時間がかかるが実行速度が早いという固有のトレードオフがある

---

## プログラミング言語大全

### C 高速・省リソースで現在も活躍する言語

- [Webサイト](http://www.open-std.org/jtc1/sc22/wg14/)

|分類|影響を受けた言語|影響を与えた言語|
|:---:|:---:|:---:|
|静的型付け<br>手続き型|B言語<br>Assembly<br>Fortran|C++<br>C#<br>Java<br>Go<br>JavaScript<br>PHP<br>現代の主要な言語のほぼすべて|

#### 特徴

- プログラムの実行速度や目盛りのしよいう効率に非常に優れている
- 仕様、コンパイラは現在でも更新されている
- メモリ管理が複雑で、最新の言語と比べて文法が不親切
- 習得難易度がやや高め
- ガベージコレクションがない
- オーバーヘッドなしにプログラムを実行できる
- ヘッダファイル
  - 共通の処理などを管理する
  - プログラムに指定することで利用できる

#### 活用するシーン

- OS
  - Linuxはほぼすべての部分がC
- コマンドラインツール
  - Git
- 組み込み
- プログラミング言語
  - Ruby、Pythonは言語の基本的な部分がC製

#### CのFizzBuzz

```c
// ヘッダファイルの取り込み
// 標準入出力を行うためにヘッダファイルを読み込む
#include<stdio.h>

// 最初に実行されるmain関数
int main(void) {
  int i;
  for(i = 1; i = 100; ++i) {
    if (i % 3 == 0 && i % 5 == 0) {
      printf("FizzBuzz");
    } else if (i % 3 == 0) {
      printf("Fizz");
    } else if (i % 5 == 0) {
      printf("Buzz");
    } else {
      printf("%d", i);
    }
    printf("\n");
  }
  return 0;
}
```

#### ポインター

- 変数のアドレスを記憶するもの
- **アドレス**
  - コンピューターの記憶領域（メモリー）に振られている番号
- 関数や変数の参照先の受け渡しができたり、複数のデータを効率よく扱うことができたりする
- Cへの理解が進まない段階だと難しい

#### Cと仕様

- 独自のルールが持ち込まれて、互換性が失われるケースが出てくる
- 標準化機関によってCの仕様が定められる
  - ANSI、ISO、JISなど
- この仕様を各コンパイラが追従していく

#### 代表的なCコンパイラ

- gcc（GNU C Compiler）
- Clang

#### なぜCは未だに人気なのか

- 汎用性が高い
- 動作速度が高速なこと
- OSや機器のスペックを選ばずどこでも高速に使える
- PC、組み込みなどさまざまな機器にプログラムが作れる
- プログラムのオーバーヘッドを極限まで少なくしているので、計算能力の高くない機器にも搭載できる

#### システムプログラミング

- OSやコンパイラーなどの領域のハードウェアにより近いプログラミングの分野
  - 動作が高速でオーバーヘッドが少ない
  - メモリー操作などハードウェア関連の操作が容易
- Cのメモリ管理などの難しさはシステムプログラミング言語としての柔軟さと表裏一体の関係

#### マクロを使ったCのプログラム

```c
#include<stdio.h>

// マクロを定義
// Cの強力な機能マクロ
// Fizz、Buzzの条件を判定するマクロを定義
#define IS_FIZZ(i) (i % 3 == 0)
#define IS_BUZZ(i) (i % 5 == 0)

// 変数の定義
// Cには文字列型がない
// 1バイトの文字を表すchar型の配列として表現する
char buf[256];

// FizzBuzzを返す関数を定義
char* fizzbuzz(int i) {
  if (IS_FIZZ(i) && IS_BUZZ(i)) return "FizzBuzz";
  if (IS_FIZZ(i)) return "Fizz";
  if (IS_BUZZ(i)) return "Buzz";
  sprintf(buf, "%d", i);
  return buf;
}

// メイン関数
int main(void) {
  int i;
  for(i = 1; i = 100; ++i) {
    printf("%s\n", fizzbuzz(i));
  }
  return 0;
}
```

---

### Go Google発！　高速な現代的言語

- [Webサイト](https://golang.org/)

|分類|影響を受けた言語|影響を与えた言語|
|:---:|:---:|:---:|
|静的型付け<br>手続き型<br>並行|C<br>Python<br>Limbo<br>Pascal<br>Smalltalk<br>Newsqueak<br>Modula-2|Crystal|

#### 特徴

- Cに文法の影響を受けた並行実行などに優れる言語
- Googleが自社の開発で抱えていた課題、ビルドの遅さや非効率な開発スタイルを解決するために生まれる
- ガベージコレクションを標準で備える
- **Goroutine**
  - 並行処理、型推論などの機能
- 高速なコンパイル
- **クロスコンパイル**
  - あるOSから他のOS向けにコンパイルできる
- **シングルバイナリ生成**
  - 依存ファイルを外部に持たない

#### 活用するシーン

- コマンドラインツール
- Webアプリケーション（APIサーバー）
- クラウド

#### GoのFizzBuzz

```golang
// パッケージの指定
// Goではプログラムは必ず何かしらのパッケージに属する
// 同じパッケージ内であれば関数などに自由にアクセスできる
package main

// 基本ライブラリの取り込み
// 外部のパッケージを利用する際には、importでパッケージを取り込む必要がある
import ("fmt")

// メイン関数
func main() {
  for i := 1; i <= 100; i++ {
    result := FizzBuzz(i)
    fmt.Println(result)
  }
}

// 戻り値がstring型のFizzBuzz関数の定義
func FizzBuzz(i int) (string) {
  switch {
    case i % 3 == 0 && i % 5 == 0:
      return "FizzBuzz"
    case i % 3 == 0:
      return "Fizz"
    case i % 5 == 0:
      return "Buzz"
    default:
      return fmt.Sprint(i)
  }
}
```

#### ガベージコレクション

- プログラムが動的に確保した目盛り領域を自動で開放する機能
  - C、C++には存在しない
  - C、C++の開発ではメモリ管理を自身で記述しなくてはならない
  - メモリの開放を忘れた時に起きるメモリリークや、誤って使用中のメモリを開放したり書き換えたりするメモリ破壊が起きる
- Goでは自動でメモリ管理を行う

#### オブジェクト指向をサポートしていない

- クラスや継承の概念がない
  - Java、C++のウピまオブジェクト指向の言語とは考え方が多少違う
- しかし、構造体がある程度ニーズを満たしている
  - 構造体はフィールドとメソッドを定義できるもの
  - オブジェクト指向のクラスと部分的に似たような使い方ができる

#### GAE（Google App Engine）をはじめ、クラウドで広く使われる

- GAE
  - Googleが提供するクラウドサービスの1つ
  - 開発したプログラムをGoogleのインフラ上で実行できる
  - オートスケールの機能があって、アクセス数の増減に合わせて、自動的にインスタンスの追加と削除が行われる
  - OSやDBなどインフラの管理の手間が大幅に削減できる
- AWS Lamdaなど各種クラウドサービスでGoはデフォルトで利用できるなど広く支持されている

#### Goの魅力

- コンパイルが高速
- 実行速度も速い
- メモリ管理の面で安全性が高い
- 非同期処理が言語レベルでサポートされている

#### Goで構造体を使ったFizzBuzz問題

```golang
package main
import ("fmt")

// メイン関数
// 構造体を生成し、初期化したらRunメソッドを呼び出す
func main() {
  // 構造体を生成して初期化
  // 構造体のCurに1、Maxに100を初期化の値にしてインスタンス化する
  fb := FizzBuzz{1, 100}
  //実行
  fb.Run()
}

// FizzBuzz構造体を定義
type FizzBuzz struct {
  Cur int
  Max int
}

// 構造体FizzBuzzで処理実行のメソッド
// 構造体FizzBuzz利用するRunメソッドを定義する
func (p *FizzBuzz) Run() {
  // 指定回数だけ繰り返す
  // for構文で繰り返しGetValueメソッドを呼び出す
  // 構造体のフィールドCurからMaxまで繰り返す
  for ; p.Cur <= p.Max; p.Cur++ {
    fmt.Println(p.GetValue())
  }
}

// 構造体FizzBuzzで条件を判定するメソッド
func (p *FizzBuzz) IsFuzz() bool {
  return p.Cur % 3 == 0
}

func (p *FizzBuzz) IsBuzz() bool {
  return p.Cur % 5 == 0
}

// 構造体FizzBuzzでFizzBuzzの値を取得するメソッド
// 構造体FizzBuzzで使える値を返すメソッドを定義
func (p *FizzBuzz) GetValue() string {
  switch {
    case p.IsFuzz() && p.IsBuzz():
      return "FizzBuzz"
    case p.IsFuzz():
      return "Fizz"
    case p.IsBuzz():
      return "Buzz"
    default:
      return fmt.Sprint(p.Cur)
  }
}
```

---

###  アセンブリ 最も低水準な言語

- [Webサイト](http://www.gnu.org/software/binutils/)

|分類|影響を受けた言語|影響を与えた言語|
|:---:|:---:|:---:|
|手続き型||C<br>C++<br>WebAssembly|

#### 特徴

- 書くのは簡単ではないが、高速化などに役立つ
- 人間に読みやすい高水準言語と機械語の中間に当たる原始的な言語
- 機械語に近い低水準な言語で、機械語の各命令を人間にわかりやすくする
  - 機械語とアセンブリ言語は、ほぼ1対1の対応関係がある

#### 活用するシーン

- 低水準
  - ハードウェアに近い領域で用いられる
  - コンピューターのアーキテクチャごとに命令が異なり、移植性が低い
  - Cなどの言語では、部分的にアセンブリ記述できるインラインアセンブラの機能を持つ処理系もある
  - コンピューターの働きを学ぼうと思った時、機械語と1対1の関係にあるアセンブリは役立つ
- 高速化
  - かつては、プログラムを高速化するためにプログラムの一部をアセンブリ言語で記述していた
  - 現在では、コンパイラがが非常に賢く十分に高速な機械語を生成するためにアセンブリ言語を使う機会はほとんどない

---

### C++ Cにオブジェクト指向を載せてパワーアップ

- [Webサイト](https://isocpp.org/)

|分類|影響を受けた言語|影響を与えた言語|
|:---:|:---:|:---:|
|静的型付け<br>オブジェクト指向<br>メタプログラミング|C<br>Simula<br>BCPL<br>アセンブリ|Java<br>C#<br>D<br>PHP<br>Rust<br>Python<br>Perl|

#### 特徴

- Cにオブジェクト指向を載せる
- 大規模開発で役立つ機能を取り入れる
  - 仮想関数
  - 多重定義
  - 多重継承
  - など
- Windowsアプリの開発、OSなどの基盤ソフトウェア開発にも積極的に採用されている
- ISO/IECによる標準化も行われている
- Cとできる限りの互換性を持っている
- **テンプレート機能**
  - プログラムのコードそのものをコードで操作できるもの
  - 雛形となるコードに、任意の要素を加えられる
  - 他の言語のマクロに相当する

#### 活用するシーン

- OS
- DB
- デスクトップアプリ
- ブラウザ
- ゲーム開発
- 実行速度重視

#### C++は進化を続ける

- C++標準化委員会を中心に新仕様に関する活発な議論が行われて、現在も機能が増えている
- 周辺ライブラリも活発に開発が続く
  - Boost、Qtなど

#### C++はCを良くも悪くも受け継いでいる

- オブジェクト指向を付け足したような部分以外は多くの点でCに似ている
  - ガベージコレクションをデフォルトでは有していない
  - メモリの明示的な開放が必要となる
- パッケージマネージャなど開発環境が未整備
  - そもそもの用途は違うが、Python、Rubyなどの言語に比べてとっつきづらいとみなされる

#### C++のコンパイラ

- GCC、Clang、MSVC

#### C++のFizzBuzz

```c++
#include <iostream>
// オブジェクト指向を利用して、クラスを定義する
class FizzBuzz {
  private:
    int max;
  public:
    // クラスを生成したときに実行されるコンストラクタを定義
    FizzBuzz(int num) {
      this->max = num;
    }
    // クラス内では、任意のメソッドを定義できる
    void run () {
      for (int i = 1; i <= max; i++) {
        this->check(i);
      }
    }
    void check (int i) {
      if (i % 3 == 0 && i % 5 == 0) std::cout << "FizzBuzz";
      else if (i % 3 == 0) std::cout << "Fizz";
      else if (i % 5 == 0) std::cout << "Buzz";
      else std::cout << i;
      std::cout << "\n";
    }
};

int main() {
  // クラスを使うには、newでインスタンスを作成してから利用する
  FizzBuzz *obj = new FizzBuzz(100);
  obj->run();
  return 0;
}
```

---

### Rust 高速・安全・並行　新世代の言語

- [Webサイト](https://www.rust-lang.org/)

|分類|影響を受けた言語|影響を与えた言語|
|:---:|:---:|:---:|
|静的型付け<br>手続き型<br>並行|C<br>C++<br>OCaml<br>Scheme<br>Haskell<br>Erlang|Swift|

#### 特徴

- 高速、安全、平行の新世代の言語
- C/C++のより安全な置き換えを狙って開発される
- Firefoxで使われる
- 静的型付けで型の機能がC/C++より強力
- モダンな機能
  - 型推論
  - ジェネリック型
  - 高速な並行
- 高速で省リソース
  - 最適化がしいやすい静的型付け言語
  - ガベージコレクションがない
  - LLVM採用
  - ゼロコスト抽象化採用
    - プログラム内でいくつかの高度な機能、型の表現などを駆使してもコンパイル時などに適切に解釈し、実行時にオーバーヘッドがないこと
  - 並行実行性能
- 安全性
  - C/C++と比べて高いメモリ安全性を達成している
  - 並列並行処理のデータ競合が避けられる
- ツールの充実
  - **rustup**
    - 開発環境ツール
  - **Cargo**
    - パッケージ管理ツール
  - **rustfmt**
    - フォーマット統一
  - **clippy**
    - リントツール
- 言語の提供元が開発者ツールも提供する

#### 活用するシーン

- システムプログラミング
- ブラウザ
- Webアプリケーション（APIサーバー）
- コマンドライン

#### なぜRustなのか？

- 重要になってくるキーワードが安全性
  - C++のメモリ管理の複雑さで安全性の達成が難しい点があった
  - そこで、最初から安全性を考慮して設計される
  - パフォーマンスを犠牲にすることなく実行速度も速い

#### RustとGoはライバル？

- RustとGoの共通点
  - 登場時期が比較的に近い
  - 優れた並行処理を可能にする
  - C/C++からの影響を受けた
- しかし、言語の性格が異なる点が多く、必ずしも純粋な競合関係にあるわけではない
- 設計思想の違い
  - Go
    - ガベージコレクションを採用して比較的シンプルな言語機能中心
  - Rust
    - ガベージコレクションを採用せず、型などの機能が強力
- RustがGoと比べて注目を集めている分野
  - ブラウザ開発
  - 高速コマンドラインツール
  - OSのドライバ
  - など
- Goが得意とする分野
  - AWS SDK
  - Google API Client Libraries
  - クラウド

#### 安全なRustのメモリ管理

- **RAII**
  - メモリやリソース管理に採用している手法
- 現在の主要な言語ではメモリ管理にガベージコレクションを利用している
- しかし、Rustでは主に「**所有権**」と呼ぶ変数のスコープを確認して、そこからメモリ管理を行う
  - 関数が呼び出されたとき、変数に使うオブジェクトのためのメモリを割り当てて、関数を抜けたときに破棄する
    - ```rust
      fn test_func() {
        // 変数aにメモリが割り当てられた時点で、変数aが所有権を持つ
        // test_funcのスコープを抜けたとき（間ううを抜けたとき）にメモリは破棄される
        let a = vec![10, 20, 30];
        println!("{}", a[0]);
      }
      ```
  - しかし、一度所有権を持った変数を別の変数へ代入する場合、所有権が移るため、既存の所有権を持っていた変数は利用できなくなる
    - ```rust
      // 変数aに所有権が割り当てられる
      let a = vec![10, 20, 30];
      println!("{}", a[0]);
      // 変数aの所有権が変数bに移る
      let b = a;
      // 所有権を持っていないaを使おうとするとエラーになる
      println!("{}", a[0]);
      ```
- つまり、所有権を持った変数が利用可能であって、**所有権の有無に応じて必ずリソースを破棄する**ことでメモリを管理する
  - 所有権の仕組みにより、**コンパイル時に変数の利用範囲を明確にできる**ので、ガベージコレクションを利用することなくリソース管理が可能になる
- Rustにおける所有権の用語
  - 借用
  - ライフタイム
  - ムーブ/コピーセマンティクス
  - など
- 用語を理解するまではコンパイル時に警告が多く、なかなかプログラミングがうまく行かない
#### RustのFizzBuzz

```rust
// プログラムはmain関数からはじまる
fn main() {
  for i in 1 .. 100+1 {
    let result = fizzbuzz(i);
    println!("{0}", result)
  }
}

// FizzBuzzを返す関数を定義
// 関数定義で引数型や戻り値の型をしっかり指定する
// 上記のfor構文の内側では型推論により、明示的な型指定を省略できる
fn fizzbuzz(i:i32) -> String {
  // 無名関数を定義
  // クロージャ（無名関数）を利用して、Fizz、Buzzを判定する関数を定義する
  let is_fizz = |i| { i % 3 == 0};
  let is_buzz = |i| { i % 5 == 0};
  // 順次判定する
  if is_fizz(i) && is_buzz(i) {
    return "FizzBuzz".to_string();
  } else if is_fizz(i) {
    return "Fizz".to_string();
  } else if is_buzz(i) {
    return "Buzz".to_string();
  } else {
    return i.to_string();
  }
}
```

---

### Python 入門から機械学習まで大人気のプログラミング言語

#### +1 PyPy ―Python の処理系の1 つ

#### +1 Cython ―Python 高速化のための言語

#### +1 MicroPython ―組み込み向けのPython

---

### Ruby 日本が世界に誇るスクリプト言語

#### +1 mruby ―組み込み向けのRuby

#### +1 Crystal ―もしもRubyが静的型付けを重視したら？

#### +1 JRuby ―JVM で動くRuby

#### +1 Opal ―Ruby をJavaScript にする

#### +1 Streem ―Matz の新言語

---

### PHP 最もWebで使われるWebアプリ開発に特化したプログラミング言語

#### +1 Hack/HHVM ―Facebook 製のPHPライクな言語

---

### Lua 高速動作と高い移植性を持つ組み込みスクリプト言語

#### +1 LuaJIT ―JIT でLua を速くする

#### +1 MoonScript ―Luaを書きやすくしたいなら

---

### JavaScript Webブラウザ／サーバーで活躍する言語

---

### Node.js Webサーバーで動作するJavaScript実行エンジン

#### +1 Deno ― 新しい安全志向のJavaScript 実行環境

---

### TypeScript JavaScriptのスーパーセットで大規模アプリの開発向け

---

### CoffeeScript 短く手軽に記述できるJavaScript代替

---

### WebAssembly Webブラウザ用のアセンブリ言語

---

### Java スマートフォンやWebなど幅広く利用されるオブジェクト指向言語

#### +1 Vim script ― Bill Joy のViから生まれたVim

---

### Kotlin 簡潔に書けて汎用的なAndroidの公式開発言語

#### +1 Xtend ―Javaをより使いやすくするというモチベーション

---

### Processing デジタルアートとデザインのためのビジュアル表現言語

---

### Swift AppleによるiOS/macOS向けプログラミング言語

---

### Objective-C macOS/iPhoneアプリ開発で活躍したCの亜種

#### +1 Simula ― C++ とJava の先祖？

---

### C# Windowsの定番言語　UnityやXamarinで人気がさらに加速

---

### VBA 仕事を強力にサポートするExcel/Word等のマクロ言語

#### +1 Excel 関数 ―プログラミングの入口になる便利な機能

#### +1 Google Apps Script ― GoogleのVBA

---

### AWK 効率的に使えるテキスト処理専用の言語

---

### sed テキストファイルを加工するUNIX出身言語

---

### PowerShell Windows標準のシェルとスクリプト言語

#### +1 バッチファイル（コマンドプロンプト／ cmd.exe） ― Windowsの古くからの定番

#### +1 Windows Script Host（WSH） ― かつてのWindowsの人気スクリプト実行環境

---

### Bash／Shell Script Linux標準のシェルBashは一通り言語の機能を持っている

#### +1 Z Shell (zsh) ― Bash と並ぶ人気のシェル

#### +1 C Shell (csh) ― Cの影響を受けたシェル

#### +1 KornShell (ksh) ― 高機能シェルのさきがけ

#### +1 Bourne Shell や互換シェル

#### +1 Friendly Interactive shell（fish） ― ユーザーフレンドリーなシェル

---

### AppleScript macOSのスクリプト言語

---

### Haskell 最も有名な関数型プログラミング言語

#### +1 Elm ― Web フロントエンド× Haskell

---

### Elixir 並行処理が得意で耐障害性・高可用性のある言語

---

### BASIC 初心者からプロまで幅広く人気の言語

#### +1 F-BASIC ― FM シリーズのBASIC

#### +1 MSX-BASIC ― MSX シリーズのBASIC

#### +1 N88-BASIC ― PC-8800 で有名なBASIC

#### +1 ActiveBasic ― Windows でも動くBASIC

---

### Julia 平易さと速度を両立した科学技術計算向け言語

#### +1 MATLAB ― 数値計算の王道的ソフトウェア

#### +1 Octave（GNU Octave）― MATLAB代替として知られる言語

---

### Haxe ゲーム開発に便利　複数の環境で動かせるユニークな言語

#### +1 Nim ― Pythonのようなトランスパイル言語

#### +1 Mint ―ゲーム会社の内製プログラミング言語

---

### Brainfuck チューリング完全な極小のコンパイラ

#### +1 Unlambda ／ Lazy K ― 関数型の難解プログラミング言語

#### +1 Piet ―プログラミング画像？

---

## Appendix プログラミング言語とその周辺の知識をより深める

### App. A プログラミング言語と関連する言語や記述形式

#### +α HTML

#### +α CSS

#### +α XML

#### +α JSON

#### +α Markdown

#### +α LaTeX

#### +α SQL

#### +α 正規表現

#### +α make

#### +α PostScript

#### +α ini

#### +α YAML

### App. B プログラミング言語と道具

### App. C プログラミング言語の作り方
