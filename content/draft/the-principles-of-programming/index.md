# まえがき

```
経験を積んだ人は、物事が後であるということを知っているが、なぜそうであるかということを知らない  
（マルティン・ハイデッガー）
```

- コードを書けるようになったものの、いまひとつ**よいコード**にならない
  - 書いたコードがリリースされる
      - 頻繁に障害発生
      - 動作が遅い
      - すぐ落ちる
  - 書いたコードを見てもらう
      - わかりにくい
      - シンプルでない
      - 美しくない
  - 書いたコードをしばらく経ってから自分で見る
      - 読みにくい
  - 書いたコードを修正する
      - 予想外のところに影響が出る
  - 書いたコードに機能を追加しようとする
      - どこを修正すればいいのかわからない
      - まったくその余地がない
  - 書いたコードに仕様変更が入る
      - その部分がすべて書き直しとなる

- 本質部分のプログラミングスキルの改善に至らない問題
  - 達人プログラマたちの名著を読んでも、敷居が高く、難しすぎて挫折したり、知識が素通りして結局得るものがない
  - プログラマとして成長しなければならない/成長したいという思いが強いほど、その方法や指針がわからない

- プリンシプル（Principle）
  - それはどういうことなのか（What）
  - それはなぜなのか、なぜ必要なのか（Why）
  - ではどうすればよいのか（How）

- プリンシプル　≒　プログラミングの指針
  - 前提
  - 原則
  - 思想
  - 習慣
  - 視点
  - 手法
  - 法則
  - 普遍的知識
  - 定説的知識
  - 本質的知識

- なぜ、プリンシプルを学ぶのか
  - プログラマとしての成長の**正道**であり、**近道**になるから
  - **特定の技術に特化したものではない**抽象度の高い情報
  - 今ある具体的な技術は、プリンシプルの目的を具現化したもの
      - より高度に達成し、より効率的に達成できるように進化し続けている

- プリンシプルの目的
  - プログラマに達成してもらうために発明される
    - コードを読みやすくする
      - 複雑性を排除する
    - コードを書きやすくする
      - コード量を少なくする
    - バグを発生しにくくする
      - 副作用をなくす
    - コードを修正しやすくする
      - 影響範囲を閉じ込める

- プリンシプルを理解すると、具体的な技術を学んだ時、その**存在理由**（なぜその技術が必要なのか）を理解できる
  - 習得が早く、深くなる
  - 知識の土台、知識の取り網が構築される
  - 技術の使い方の格段が上がり、目的に沿った形で、正しく適用できるようになる

# 序章

```
持っていることは、なるほどすてきだ。  
だが、理解もしばければならない。  
意欲が何かをなすためには、能力、それもたいしたものだ  
（ヨハン・ヴォルフガング・フォン・ゲーテ）
```

## プリンシプルのカテゴリ

- 各章（カテゴリ）に紹介する内容

### 前提（プログラミングの変わらぬ真実）

- プログラミングの**普遍的な事実**
- 事実であってテクニックではない
- 全プリンシプルの前提知識となるもの
- **プログラミングとはこういうもの**と受け入れ、コードを書くときの前提にする

### 原則（プログラミングのガイドライン）

- 多くの場合、共通に適用されるべき、プログラミングにおける基本的な**きまりごと**
- 鉄則と比べると、例外を認める、緩やかな規則となる
- 原則どおりに考えて、状況尾に応じて調整するようにすると、筋のよいコードになっていく

### 思想（プログラミングのイデオロギー）

- 本書で紹介する思想
  - プログラミングセオリー
  - アーキテクチャ根底技法
  - アーキテクチャ非機能要件
  - 7つの設計原理
  - UNIX思想
  - UNIX哲学
- 成功したソフトウェアには、その成功を支えた文化、哲学、価値観がある
  - 思想的下支えがあるからこそ、ブレが生じなく、成功できた


### 視点（プログラミングの観る角度）

- 将来に渡って改善しやすいコードを書く
  - 「こういう視点で考えて、こういう要素を考えておくと、後々よい」という**生きの長いコード**に刷るための視点、見方

### 習慣（プログラミングのルーティーン）

- よいコードになる習慣、行動指針

### 手法（プログラミングの道具箱）

- コードを書くことは、脳に角の負担をかける思考の作業
- 何度も策を講じないと、オーバーフロー/オーバーヒートしてしまう
  - ケース漏れが発生して、品質が悪くなる
  - 要件ズレが発生してユーザーの思いとは乖離した役に立たないソフトウェアができてしまう
- こういう事態を防ぐために、達人たちは思考フレームワーク、設計手法、問題解決手法にこだわる

### 法則（プログラミングのアンチパターン）

- アンチパターン
  - 帰納的に導き出された、否定的な結果を生む経験則
  - 失敗に至る必然的な道筋がある
  - 事前に因果関係を知っておくことで、開発の作業や運営に活かせる

## プリンシプルの説明における用語法

### ソフトウェア

- 定義：プログラミングによる成果物
  - アプリケーション
  - プログラム
  - システム
  - ツール
- 応用ソフトウェア（アプリケーション）
- 基本ソフトウェア（OS）

### コード

- 定義：プログラミングで書くもの
  - ソースコード
  - ソース
  - プログラム
  - ソースプログラム

### プログラミング

- 定義：コードを書く行為
  - コーディング
- 実装
  - インタフェースやモジュールの裏に描かれているコード

### プログラマ

- 定義：プログラミングをする人
  - 開発者
  - デベロッパー
  - エンジニア
  - ソフトウェアエンジニア
  - メンバー
  - コーダー

### 関数

- 定義：コードの一部を切り出し、呼び出し可能としたもの
  - ルーチン
  - ファンクション
  - プロシージャ
  - メッセージ
  - メソッド
  - メンバー関数

### モジュール

- 定義：関数や変数を、ある責任単位でまとめたもの
  - 関連の強いコードをまとめたもの
  - クラス
  - ファイル
  - コンポーネント
  - 部品
  - ライブラリ

### アーキテクチャ

- 定義：ソフトウェア全体の構造
  - モジュールよりレベルが上の、全体の構造設計
  - 構造思想

# 1章（プログラミングの変わらぬ真実）

```
どの港へ向かうのかを知らぬ者にとっては、  
いかなる風も順風たり得ない  
（ルキウス・アンナエウス・セネカ）
```

## プログラミングに銀の弾丸はない

`No Silver Bullet in programming.`

### What

- プログラミングに特効薬はない
- プログラミングには、魔法のような解決策がない

### Why

- プログラミングの成果物である「ソフトウェア」は、本質的に「困難性」を持っている
- 困難性を示す4つの性質
  - 1. 複雑性
    - ソフトウェア構成要素間の依存関係も、規模が大きくなるほど非線形に増大する
  - 2. 同調性
    - 実世界に同調し続けなくてはならない
    - ソフトウェアは、単独で存在しているわけではなく、ハードウェア/ネットワーク/他のソフトウェア/人間の行為や習慣など、実世界の様々なものと関係を持ち続ける
  - 3. 可変性
    - 計画通りにソフトウェアができあがっても、ユーザーはさらなる要求を思いついてしまう
    - できあがったソフトウェアが世界の側を変えてしまう
    - ソフトウェアがそのユーザーの認識にも影響を及ぼし、新たな要求が発生してしまう
  - 4. 不可視性
    - 概念の集積である
    - 製品そのものやプロセス、意思決定の経緯なども見ることができない
    - 抽象化して、単純な図面にすることは可能だけど、情報を捨象するので、全部を表現することはできない
    - 原理上不可視なため、難易度は増大する
- 本質が定義上取り除けないもので、ソフトウェアの本質が困難性である以上、これを成果物とするプログラミング活動も困難になる
- 取り巻く状況が複雑で、問題が多岐に渡りすぎて、すべてを解決する特効薬は存在しえない

### How

- 歴史を学び「複雑さ」と戦う
- ソフトウェア開発について、歴史を学び、地道に改善する
- 特効薬の喧伝に踊らされ、登場しそうもない解決策を待つのではなく、地道で科学的なアプローチによる改善が必要
- ソフトウェア開発の歴史は、実は、複雑さとの戦いの歴史

### 発展

- 物事の2面性
    - 本質的
      - その対象物において、それがなければ対象物とは言えなくなる性質
    - 偶有的
      - 「副次的」「付随的」という意味
      - なくても対象物が成り立つような性質
- ソフトウェア開発の現場で必要な「スキル」　→　大半は、偶有的なもの
  - ビルド環境
  - プログラミング言語
  - ライブラリ
  - フレームワーク
- 本質的な部分の活動に注力するためには、偶有的な部分の活動が大きな役割を果たす
  - なぜなら、偶有的な部分は、本質的な部分とは対照的に、容易に改善できる
  - 適切なプログラミング言語を選ぶだけで、劇的に生産性が上がる
- 偶有部分の改善の中で、特に大きな実績を上げてきたのが「自動化」
  - テスト/ビルド/環境作成などの自動化で、作業効率や作業品質が大きく改善される
  - 偶有的な部分を見つけたら、自動化して、本質的な部分にできるだけ時間を割けるようにする

## コードは設計書である

`Code as design.`

### What

- コードこそが設計書

### Why

### How

### 発展

## 
### What
### Why
### How
### 発展

# 2章

# 3章

# 4章

# 5章

# 6章

# 7章
